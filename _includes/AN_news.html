<!-- Supabase HN Clone -->
<style>
  /* AI News - Clean list style matching links section */

  /* Controls */
  .hn-controls-wrapper {
    padding: 0.5rem 0;
    margin-bottom: 0.75rem;
    border-bottom: 1px solid var(--global-divider-color);
  }
  .hn-controls-row {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-wrap: wrap;
  }
  .hn-search-input {
    flex: 1;
    min-width: 150px;
    padding: 0.3rem 0.6rem;
    border: 1px solid var(--global-divider-color);
    border-radius: 3px;
    font-size: 0.85rem;
    font-family: inherit;
    background-color: var(--global-bg-color);
    color: var(--global-text-color);
    transition: border-color 0.2s ease;
  }
  .hn-search-input:focus {
    outline: none;
    border-color: var(--global-theme-color);
  }
  .hn-search-input::placeholder {
    color: var(--global-text-color-light);
    opacity: 0.5;
  }
  .hn-sort-select {
    padding: 0.3rem 1.5rem 0.3rem 0.6rem;
    border: 1px solid var(--global-divider-color);
    border-radius: 3px;
    font-size: 0.85rem;
    font-family: inherit;
    background-color: var(--global-bg-color);
    color: var(--global-text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 12 12'%3E%3Cpath fill='%232698BA' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.4rem center;
    transition: border-color 0.2s ease;
  }
  .hn-sort-select:focus {
    outline: none;
    border-color: var(--global-theme-color);
  }

  /* Buttons */
  .hn-btn {
    padding: 0.3rem 0.7rem;
    border: 1px solid;
    border-radius: 3px;
    font-size: 0.8rem;
    font-family: inherit;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
  }
  .hn-btn-primary {
    border-color: var(--global-theme-color);
    color: var(--global-theme-color);
    background: none;
  }
  .hn-btn-primary:hover {
    color: var(--global-bg-color);
    background-color: var(--global-theme-color);
  }
  .hn-btn-success {
    border-color: #00ab37;
    color: #00ab37;
    background: none;
  }
  .hn-btn-success:hover {
    color: white;
    background-color: #00ab37;
  }
  .hn-btn-danger {
    border-color: #FF3636;
    color: #FF3636;
    background: none;
  }
  .hn-btn-danger:hover {
    color: white;
    background-color: #FF3636;
  }
  .hn-btn-secondary {
    border-color: var(--global-divider-color);
    color: var(--global-text-color-light);
    background: none;
  }
  .hn-btn-secondary:hover {
    border-color: var(--global-text-color-light);
  }

  /* Post Form */
  .hn-post-form {
    padding: 0.75rem 0;
    margin-bottom: 0.75rem;
    border-bottom: 1px solid var(--global-divider-color);
  }
  .hn-post-form-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
  }
  .hn-post-form-title {
    font-size: 0.9rem;
    font-weight: 500;
    color: var(--global-text-color);
    margin: 0;
  }
  .hn-user-info {
    font-size: 0.8rem;
    color: var(--global-text-color-light);
    margin-right: 0.75rem;
  }
  .hn-post-form input {
    width: 100%;
    padding: 0.35rem 0.6rem;
    margin-bottom: 0.5rem;
    border: 1px solid var(--global-divider-color);
    border-radius: 3px;
    font-size: 0.85rem;
    font-family: inherit;
    background-color: var(--global-bg-color);
    color: var(--global-text-color);
    transition: border-color 0.2s ease;
  }
  .hn-post-form input:focus {
    outline: none;
    border-color: var(--global-theme-color);
  }

  /* Stories table */
  .hn-stories-container {
    display: table;
    width: 100%;
    border-collapse: collapse;
  }
  .hn-story {
    display: table-row;
    font-size: 0.95rem;
    line-height: 1.4;
  }
  .hn-story > div {
    display: table-cell;
    padding: 0.35rem 0;
    border-bottom: 1px solid var(--global-divider-color);
    vertical-align: baseline;
  }
  .hn-col-vote {
    white-space: nowrap;
    width: 3rem;
    padding-right: 0.4rem !important;
  }
  .hn-upvote-btn {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 0.8rem;
    color: var(--global-text-color-light);
    padding: 0;
    line-height: 1;
    opacity: 0.5;
    transition: opacity 0.2s ease, color 0.2s ease;
  }
  .hn-upvote-btn:hover {
    opacity: 1;
    color: var(--global-theme-color);
  }
  .hn-points {
    font-size: 0.8rem;
    font-weight: 500;
    color: var(--global-theme-color);
    margin-left: 0.15rem;
  }
  .hn-col-title {
    max-width: 0;
    width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 0.75rem !important;
  }
  .hn-col-title a {
    color: var(--global-text-color);
    text-decoration: none;
    transition: color 0.2s ease;
  }
  .hn-col-title a:hover {
    color: var(--global-theme-color);
  }
  .hn-domain {
    font-size: 0.75rem;
    color: var(--global-text-color-light);
    opacity: 0.6;
    margin-left: 0.3rem;
  }
  .hn-domain::before { content: "("; }
  .hn-domain::after { content: ")"; }
  .hn-col-author {
    white-space: nowrap;
    font-size: 0.8rem;
    color: var(--global-text-color-light);
    padding-right: 0.75rem !important;
  }
  .hn-col-author a {
    color: var(--global-text-color-light);
    text-decoration: none;
    transition: color 0.2s ease;
  }
  .hn-col-author a:hover {
    color: var(--global-theme-color);
  }
  .hn-col-time {
    white-space: nowrap;
    font-size: 0.8rem;
    color: var(--global-text-color-light);
    opacity: 0.6;
    text-align: right;
  }
  .hn-story-header > div {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--global-theme-color);
    border-bottom: 2px solid var(--global-theme-color) !important;
    padding-bottom: 0.3rem !important;
    opacity: 1;
  }
  .hn-delete-btn {
    color: #FF3636;
    text-decoration: none;
    cursor: pointer;
    font-size: 0.75rem;
    opacity: 0.6;
    transition: opacity 0.2s ease;
    margin-left: 0.3rem;
  }
  .hn-delete-btn:hover { opacity: 1; }

  /* Comments */
  .hn-comments-section {
    margin-top: 0.5rem;
    padding-top: 0.5rem;
    border-top: 1px solid var(--global-divider-color);
  }
  .hn-comment {
    margin-bottom: 0.5rem;
    padding-left: 0.75rem;
    font-size: 0.85rem;
    color: var(--global-text-color);
  }
  .hn-comment-author {
    color: var(--global-text-color-light);
    font-weight: 500;
    margin-right: 0.25rem;
  }
  .hn-comment-input {
    width: 100%;
    padding: 0.35rem 0.6rem;
    margin-bottom: 0.5rem;
    border: 1px solid var(--global-divider-color);
    border-radius: 3px;
    font-size: 0.85rem;
    font-family: inherit;
    background-color: var(--global-bg-color);
    color: var(--global-text-color);
    resize: vertical;
  }
  .hn-comment-input:focus {
    outline: none;
    border-color: var(--global-theme-color);
  }

  /* Utility */
  .hn-hide { display: none !important; }
  .hn-empty-state {
    text-align: center;
    padding: 2rem 1rem;
    color: var(--global-text-color-light);
    font-size: 0.9rem;
    opacity: 0.6;
  }
  .hn-loading-state {
    text-align: center;
    padding: 1.5rem 1rem;
    color: var(--global-text-color-light);
    font-size: 0.9rem;
    opacity: 0.6;
  }

  /* Dark mode */
  [data-theme="dark"] .hn-sort-select {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 12 12'%3E%3Cpath fill='%23FF7F50' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
  }

  /* Responsive */
  @media (max-width: 768px) {
    .hn-controls-row {
      flex-direction: column;
      align-items: stretch;
    }
    .hn-search-input { min-width: 100%; }
    .hn-stories-container {
      display: block;
    }
    .hn-story {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      padding: 0.35rem 0;
      border-bottom: 1px solid var(--global-divider-color);
    }
    .hn-story > div {
      display: inline;
      padding: 0;
      border-bottom: none;
    }
    .hn-story-header {
      display: none;
    }
    .hn-col-vote {
      width: auto;
      margin-right: 0.3rem;
    }
    .hn-col-title {
      flex: 1;
      max-width: none;
      white-space: normal;
      overflow: visible;
    }
    .hn-col-author {
      width: 100%;
      text-align: left;
      padding-left: 2.6rem;
      padding-top: 0.1rem;
    }
    .hn-col-time {
      width: auto;
      text-align: left;
      padding-left: 0.5rem;
    }
    .hn-post-form-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }
  }
</style>

<!-- Controls Section -->
<div class="hn-controls-wrapper">
  <div class="hn-controls-row">
    <input type="text" id="hn-search-input" placeholder="Search stories..." class="hn-search-input">
    <button id="hn-search-btn" class="hn-btn hn-btn-primary">Search</button>
    <button id="hn-clear-search-btn" class="hn-btn hn-btn-secondary">Clear</button>
    <button id="hn-login-btn-header" class="hn-btn hn-btn-primary hn-hide">Login</button>
    <button id="hn-post-toggle" class="hn-btn hn-btn-success hn-hide">+ Post</button>
    <select id="hn-sort-select" class="hn-sort-select">
      <option value="new">New</option>
      <option value="hot">Hot</option>
      <option value="top">Top</option>
    </select>
  </div>
</div>

<!-- Post Form (only visible to logged-in users) -->
<div id="hn-post-form" class="hn-post-form hn-hide" style="display: none;">
  <div class="hn-post-form-header">
    <h3 class="hn-post-form-title">Post a Link</h3>
    <div style="display: flex; align-items: center;">
      <span id="hn-user-email" class="hn-user-info"></span>
      <button id="hn-logout-btn" class="hn-btn hn-btn-danger">Logout</button>
    </div>
  </div>
  <input type="text" id="hn-title-input" placeholder="Title..." required>
  <input type="url" id="hn-url-input" placeholder="URL (e.g., https://example.com)" required>
  <button id="hn-post-btn" class="hn-btn hn-btn-success">Post</button>
</div>

<!-- Stories Container -->
<div id="hn-stories-container" class="hn-stories-container"></div>

   <script>
   // Supabase Configuration - using Jekyll include parameters
   const SUPABASE_URL = '{{ include.supabase_url }}';
   const SUPABASE_ANON_KEY = '{{ include.supabase_anon_key }}';

   // Configuration
   const STORIES_LIMIT = 100;  // Number of stories to display
   const FALLBACK_FETCH_LIMIT = 500;  // Number of stories to fetch for fallback sorting
   const TOP_TIME_LIMIT_DAYS = 365;  // Time lookback for "top" mode (1 year)
   const HOT_TIME_LIMIT_DAYS = 90;   // Time lookback for "hot" mode (3 months)
   const SHOW_GITHUB_USERNAMES = true;  // Set to false to show UIDs instead of GitHub usernames

   // HTML escaping function to prevent XSS
   function escapeHtml(unsafe) {
     return unsafe
       .replace(/&/g, "&amp;")
       .replace(/</g, "&lt;")
       .replace(/>/g, "&gt;")
       .replace(/"/g, "&quot;")
       .replace(/'/g, "&#039;");
   }

   // Extract domain from URL
   function extractDomain(url) {
     try {
       const urlObj = new URL(url);
       return urlObj.hostname.replace(/^www\./, '');
     } catch (e) {
       return '';
     }
   }

   // Calculate relative time (e.g., "2 hours ago", "3 days ago")
   function getRelativeTime(dateString) {
     const now = new Date();
     const past = new Date(dateString);
     const diffMs = now - past;
     const diffSec = Math.floor(diffMs / 1000);
     const diffMin = Math.floor(diffSec / 60);
     const diffHour = Math.floor(diffMin / 60);
     const diffDay = Math.floor(diffHour / 24);
     const diffMonth = Math.floor(diffDay / 30);
     const diffYear = Math.floor(diffDay / 365);

     if (diffYear > 0) {
       return diffYear === 1 ? '1 year ago' : `${diffYear} years ago`;
     } else if (diffMonth > 0) {
       return diffMonth === 1 ? '1 month ago' : `${diffMonth} months ago`;
     } else if (diffDay > 0) {
       return diffDay === 1 ? '1 day ago' : `${diffDay} days ago`;
     } else if (diffHour > 0) {
       return diffHour === 1 ? '1 hour ago' : `${diffHour} hours ago`;
     } else if (diffMin > 0) {
       return diffMin === 1 ? '1 minute ago' : `${diffMin} minutes ago`;
     } else {
       return 'just now';
     }
   }

   // Load Supabase SDK if not already loaded
   if (!window.supabase) {
     const script = document.createElement('script');
     script.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
     script.async = true;
     script.onload = () => {
       setTimeout(initSupabase, 100); // Small delay to ensure DOM is ready
     };
     script.onerror = () => {
       alert('Failed to load Supabase SDK. Please refresh the page.');
     };
     document.head.appendChild(script);
   } else {
     // Ensure DOM is ready before initializing
     if (document.readyState === 'loading') {
       document.addEventListener('DOMContentLoaded', initSupabase);
     } else {
       initSupabase();
     }
   }

   function initSupabase() {
     if (!window.supabase) {
       alert('Failed to initialize. Please refresh the page.');
       return;
     }

     const { createClient } = window.supabase;
     const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

     let isInitialLoad = true;
     let debounceTimer = null;

     // DOM Elements
     const loginBtnHeader = document.getElementById('hn-login-btn-header');
     const logoutBtn = document.getElementById('hn-logout-btn');
     const postForm = document.getElementById('hn-post-form');
     const postToggle = document.getElementById('hn-post-toggle');
     const storiesContainer = document.getElementById('hn-stories-container');
     const titleInput = document.getElementById('hn-title-input');
     const urlInput = document.getElementById('hn-url-input');
     const postBtn = document.getElementById('hn-post-btn');
     const userEmailSpan = document.getElementById('hn-user-email');
     const searchInput = document.getElementById('hn-search-input');
     const searchBtn = document.getElementById('hn-search-btn');
     const clearSearchBtn = document.getElementById('hn-clear-search-btn');
     const sortSelect = document.getElementById('hn-sort-select');

     let currentSearchTerm = '';
     let currentSortBy = 'new';
     let currentSession = null;
     let searchDebounceTimer = null;
     let isRefreshing = false; // Prevent race conditions
     let refreshTimeoutId = null; // Safety timeout to reset isRefreshing

     // Helper function to properly reset refresh state
     function resetRefreshState() {
       clearTimeout(refreshTimeoutId);
       isRefreshing = false;
     }

     // Fetch GitHub usernames for an array of user IDs
     async function fetchGithubUsernames(userIds) {
       if (!userIds || userIds.length === 0) return {};

       try {
         const { data, error } = await supabase.rpc('get_github_usernames', {
           user_ids: userIds
         });

         if (error) throw error;

         // Convert to lookup map: user_id → {github_username, avatar_url}
         const usernameMap = {};
         (data || []).forEach(row => {
           usernameMap[row.user_id] = {
             username: row.github_username || 'unknown',
             avatar: row.avatar_url || null
           };
         });

         return usernameMap;
       } catch (err) {
         console.error('Error fetching GitHub usernames:', err);
         return {};
       }
     }

     // Auth State Management
     function updateUI(session) {
       currentSession = session;

       if (session) {
         // User is logged in
         if (loginBtnHeader) loginBtnHeader.classList.add('hn-hide');
         if (postToggle) postToggle.classList.remove('hn-hide');
         if (userEmailSpan) userEmailSpan.textContent = `Logged in as: ${session.user.email}`;
       } else {
         // User is not logged in - ensure complete UI reset
         if (loginBtnHeader) loginBtnHeader.classList.remove('hn-hide');
         if (postToggle) {
           postToggle.classList.add('hn-hide');
           postToggle.textContent = '+ Post'; // Reset button text
         }
         if (postForm) {
           postForm.classList.add('hn-hide');
           postForm.style.display = 'none';
         }
         if (userEmailSpan) userEmailSpan.textContent = ''; // Clear email display
       }
     }

     // Initialize auth and stories
     async function initialize() {
       try {
         const { data: { session }, error } = await supabase.auth.getSession();
         if (!error) {
           updateUI(session);
         }
         // Always load stories once on initialization
         await fetchStories();
         isInitialLoad = false;
       } catch (err) {
         storiesContainer.innerHTML = '<p style="color: red;">Failed to initialize. Please refresh the page.</p>';
       }
     }

     // Set up auth state listener (but prevent duplicate calls)
     supabase.auth.onAuthStateChange((event, session) => {
       if (!isInitialLoad) {
         updateUI(session);
         // Only refresh stories on actual auth changes, not on initial load
         if (event === 'SIGNED_IN' || event === 'SIGNED_OUT') {
           clearTimeout(debounceTimer);
           debounceTimer = setTimeout(() => fetchStories(), 500);
         }
       }
     });

     // Start initialization
     initialize();

     // Debug function to manually reset isRefreshing state (can be called from console)
     window.resetRefreshState = resetRefreshState;

     async function login() {
       try {
         const { error } = await supabase.auth.signInWithOAuth({
           provider: 'github',
           options: {
             redirectTo: window.location.origin + window.location.pathname
           }
         });
         if (error) {
           alert('Login failed: ' + error.message);
         }
       } catch (err) {
         alert('Login error: ' + err.message);
       }
     }

     async function logout() {
       try {
         // Check current session first
         const { data: { session: currentAuthSession } } = await supabase.auth.getSession();

         if (!currentAuthSession) {
           // Session already cleared - just update UI
           currentSession = null;
           updateUI(null);
           return;
         }

         const { error } = await supabase.auth.signOut();
         if (error) {
           // Handle specific session-related errors gracefully
           if (error.message.includes('Auth session missing') || error.message.includes('session')) {
             // Force UI reset even if signOut fails due to session issues
             currentSession = null;
             updateUI(null);
           } else {
             alert('Logout failed: ' + error.message);
           }
         }
       } catch (err) {
         // For any other errors, still try to clear local state
         if (err.message.includes('Auth session missing') || err.message.includes('session')) {
           currentSession = null;
           updateUI(null);
         } else {
           alert('Logout error: ' + err.message);
         }
       }
     }

     // Story Functions
     async function fetchStories() {
       try {
         if (!storiesContainer) return;

         storiesContainer.innerHTML = '<div class="hn-loading-state">Loading stories...</div>';
         await refreshStories();
       } catch (err) {
         if (storiesContainer) {
           storiesContainer.innerHTML = `<p style="color: red; font-size: 0.7em;">Error loading stories: ${err.message}</p>`;
         }
       }
     }

     async function refreshStories() {
       try {
         if (!supabase || !storiesContainer || isRefreshing) return;

         isRefreshing = true;

         // Safety timeout to reset isRefreshing after 10 seconds
         clearTimeout(refreshTimeoutId);
         refreshTimeoutId = setTimeout(() => {
           isRefreshing = false;
         }, 10000);

        // Escape Postgres LIKE wildcards and special chars in user input
        function escapeLike(str) {
          return str.replace(/[\\%_'";]/g, '\\\\$&');
        }

         // Time-optimized queries based on sort mode
         let baseQuery = supabase.from('stories').select(`
           id, title, url, author_id, created_at,
           votes(vote_type)
         `);

         // Add search filter if specified
         if (currentSearchTerm) {
           const escaped = escapeLike(currentSearchTerm);
           const searchTerm = `%${escaped}%`;
           baseQuery = baseQuery.or(`title.ilike.${searchTerm},url.ilike.${searchTerm}`);
         }

         // Apply time constraints and limits based on sort mode
         const now = new Date();
         let fetchLimit;

         switch (currentSortBy) {
           case 'new':
             // Fetch only recent stories, ordered by creation time
             fetchLimit = STORIES_LIMIT;
             baseQuery = baseQuery
               .order('created_at', { ascending: false })
               .limit(fetchLimit);
             break;

           case 'top':
             // Fetch stories from last year for "top in last year"
             const topCutoff = new Date(now.getTime() - (TOP_TIME_LIMIT_DAYS * 24 * 60 * 60 * 1000));
             baseQuery = baseQuery
               .gte('created_at', topCutoff.toISOString())
               .order('created_at', { ascending: false });
             break;

           case 'hot':
           default:
             // Fetch stories from last 3 months for hot calculation
             const hotCutoff = new Date(now.getTime() - (HOT_TIME_LIMIT_DAYS * 24 * 60 * 60 * 1000));
             baseQuery = baseQuery
               .gte('created_at', hotCutoff.toISOString())
               .order('created_at', { ascending: false });
             break;
         }

         const { data: allStories, error } = await baseQuery;
         if (error) {
           storiesContainer.innerHTML = `<p style="color: red; font-size: 0.7em;">Error: ${error.message}</p>`;
           resetRefreshState();
           return;
         }

         // Process stories based on sort mode
         let stories;

         if (currentSortBy === 'new') {
           // For "new" mode, stories are already sorted by creation time
           // Just add points for display
           stories = (allStories || []).map(story => {
             const points = (story.votes || []).reduce((sum, vote) => sum + (vote.vote_type || 0), 0);
             return { ...story, points };
           }).slice(0, STORIES_LIMIT);

         } else {
           // For "top" and "hot" modes, calculate points and sort
           const storiesWithPoints = (allStories || []).map(story => {
             const points = (story.votes || []).reduce((sum, vote) => sum + (vote.vote_type || 0), 0);
             return { ...story, points };
           });

           switch (currentSortBy) {
             case 'top':
               // Sort by points within the time window
               stories = storiesWithPoints
                 .sort((a, b) => b.points - a.points)
                 .slice(0, STORIES_LIMIT);
               break;

             case 'hot':
             default:
               // Apply hot score formula within the time window
               stories = storiesWithPoints
                 // For 1000 items, this is acceptable in the browser: O(n) for mapping, O(n log n) for sort.
                 // If you expect much larger datasets, consider server-side sorting or pagination.
                 .sort((a, b) => {
                   // Precompute ages and scores for both items
                   const now = Date.now();
                   const ageA = (now - new Date(a.created_at).getTime()) / (1000 * 60 * 60);
                   const ageB = (now - new Date(b.created_at).getTime()) / (1000 * 60 * 60);
                   const scoreA = a.points / Math.pow(ageA + 2, 1.5);
                   const scoreB = b.points / Math.pow(ageB + 2, 1.5);
                   return scoreB - scoreA;
                 })
                 .slice(0, STORIES_LIMIT);
               break;
           }
         }

         if (!stories || stories.length === 0) {
           renderStories([]);
           resetRefreshState();
           return;
         }

         // Get user votes for logged-in users
         let userVotesMap = {};
         if (currentSession) {
           const storyIds = stories.map(s => s.id);
           const { data: userVotes } = await supabase
             .from('votes')
             .select('story_id, vote_type')
             .in('story_id', storyIds)
             .eq('user_id', currentSession.user.id);

           if (userVotes) {
             userVotes.forEach(vote => {
               userVotesMap[vote.story_id] = vote;
             });
           }
         }

         // Merge user vote data
         const storiesWithVotes = stories.map(story => ({
           ...story,
           userVote: userVotesMap[story.id] || null
         }));

         // Conditionally fetch GitHub usernames based on configuration
         let githubNames = {};
         if (SHOW_GITHUB_USERNAMES) {
           const uniqueAuthorIds = [...new Set(storiesWithVotes.map(s => s.author_id).filter(Boolean))];
           githubNames = await fetchGithubUsernames(uniqueAuthorIds);
         }

         // Attach GitHub info to stories
         const storiesWithGithubNames = storiesWithVotes.map(story => ({
           ...story,
           github_username: githubNames[story.author_id]?.username || null,
           github_avatar: githubNames[story.author_id]?.avatar || null
         }));

         renderStories(storiesWithGithubNames);
         resetRefreshState();

       } catch (err) {
         if (storiesContainer) {
           storiesContainer.innerHTML = `<p style="color: red; font-size: 0.7em;">Error: ${err.message}</p>`;
         }
         resetRefreshState();
       }
     }

     function renderStories(stories = []) {
       try {
         if (!storiesContainer) return;

         storiesContainer.innerHTML = '';
         if (stories.length === 0) {
           storiesContainer.innerHTML = '<div class="hn-empty-state">No stories yet—be the first to post!</div>';
           return;
         }

         // Add header row
         const headerRow = document.createElement('div');
         headerRow.className = 'hn-story hn-story-header';
         headerRow.innerHTML = `
           <div class="hn-col-vote"></div>
           <div class="hn-col-title">Title</div>
           <div class="hn-col-author">Posted by</div>
           <div class="hn-col-time">When</div>
         `;
         storiesContainer.appendChild(headerRow);

         stories.forEach(story => {
           const storyElement = document.createElement('div');
           storyElement.className = 'hn-story';
           storyElement.dataset.storyId = story.id;

           const relativeTime = getRelativeTime(story.created_at);

           // Check if user has voted
           const userVote = story.userVote?.vote_type || 0;
           const voteDisplay = userVote === 1 ? '▼' : '▲';

           // Format points with + prefix (no downvoting, so always positive)
           const pointsDisplay = `+${story.points}`;

           // Check if user owns this story
           const isOwner = currentSession && story.author_id === currentSession.user.id;
           const deleteButton = isOwner ? `<a href="#" class="hn-delete-btn" data-story-id="${story.id}">delete</a>` : '';

           // Display author name based on configuration
           let authorDisplay;
           if (SHOW_GITHUB_USERNAMES && story.github_username) {
             const escapedUsername = escapeHtml(story.github_username);
             authorDisplay = `<a href="https://github.com/${escapedUsername}" target="_blank" rel="noopener noreferrer">${escapedUsername}</a>`;
           } else if (story.author_id) {
             authorDisplay = story.author_id.slice(0, 8) + '...';
           } else {
             authorDisplay = 'unknown';
           }

           // Extract domain from URL
           const domain = extractDomain(story.url);

          storyElement.innerHTML = `
            <div class="hn-col-vote">
              <button class="hn-upvote-btn" data-story-id="${story.id}">${voteDisplay}</button>
              <span class="hn-points">${pointsDisplay}</span>
            </div>
            <div class="hn-col-title">
              <a href="${story.url}" target="_blank" rel="noopener noreferrer">${escapeHtml(story.title)}</a>
              ${domain ? `<span class="hn-domain">${escapeHtml(domain)}</span>` : ''}
            </div>
            <div class="hn-col-author">
              ${authorDisplay}${deleteButton ? ` ${deleteButton}` : ''}
            </div>
            <div class="hn-col-time">
              ${relativeTime}
            </div>
          `;

           storiesContainer.appendChild(storyElement);
         });

         // Event listeners will be handled by delegation on storiesContainer
       } catch (err) {
         // Silently fail rendering
       }
     }

   async function handleUpvote(e) {
     const btn = e.currentTarget || e.target;
     const storyId = btn.dataset.storyId;

     try {
       if (!currentSession) {
         // Trigger login if not logged in
         await login();
         return;
       }

       // Read the current vote state from the database
       const { data: existingVote, error: voteCheckError } = await supabase
         .from('votes')
         .select('vote_type')
         .eq('story_id', storyId)
         .eq('user_id', currentSession.user.id)
         .single();

       if (voteCheckError && voteCheckError.code === 'PGRST116') {
         // No vote exists: create/upsert an upvote
         const { error } = await supabase
           .from('votes')
           .upsert({ story_id: storyId, user_id: currentSession.user.id, vote_type: 1 }, { onConflict: 'story_id,user_id' });
         if (error) throw error;
       } else if (voteCheckError) {
         // Unexpected error fetching current vote
         throw voteCheckError;
       } else if (existingVote && existingVote.vote_type === 1) {
         // Toggle off existing upvote
         const { error } = await supabase
           .from('votes')
           .delete()
           .eq('story_id', storyId)
           .eq('user_id', currentSession.user.id);
         if (error) throw error;
       } else {
         // Change to upvote (covers existing downvote or null cases handled above)
         const { error } = await supabase
           .from('votes')
           .upsert({ story_id: storyId, user_id: currentSession.user.id, vote_type: 1 }, { onConflict: 'story_id,user_id' });
         if (error) throw error;
       }

       // Refresh stories to get updated vote counts and points
       await refreshStories();

     } catch (error) {
       alert('Upvote failed: ' + error.message);
     }
   }

     // Comment Functions
     function toggleComments(e) {
       e.preventDefault();
       const btn = e.currentTarget || e.target;
       const storyId = btn.dataset.storyId;
       const commentsSection = document.querySelector(`.hn-comments-section[data-story-id="${storyId}"]`);
       if (commentsSection) {
         commentsSection.classList.toggle('hn-hide');
         if (!commentsSection.classList.contains('hn-hide')) {
           loadComments(storyId);
         }
       }
     }

     async function loadComments(storyId) {
       const commentsList = document.querySelector(`.hn-comments-list[data-story-id="${storyId}"]`);
       if (!commentsList) return;
       commentsList.innerHTML = '<p style="font-size: 0.85rem;">Loading comments...</p>';

       try {
         const { data: comments, error } = await supabase
           .from('comments')
           .select('id, content, author_id, created_at')
           .eq('story_id', storyId)
           .order('created_at', { ascending: true });

         if (error) throw error;
         if (comments.length === 0) {
           commentsList.innerHTML = '<p style="font-size: 0.85rem;">No comments yet.</p>';
         } else {
           // Conditionally fetch GitHub usernames based on configuration
           let githubNames = {};
           if (SHOW_GITHUB_USERNAMES) {
             const commentAuthorIds = [...new Set(comments.map(c => c.author_id).filter(Boolean))];
             githubNames = await fetchGithubUsernames(commentAuthorIds);
           }

           commentsList.innerHTML = '';
           comments.forEach(comment => {
             const timeAgo = new Date(comment.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

             // Display author name based on configuration
             let authorNameHTML;
             if (SHOW_GITHUB_USERNAMES && githubNames[comment.author_id]) {
               const username = githubNames[comment.author_id].username;
               const escapedUsername = escapeHtml(username);
               authorNameHTML = `<a href="https://github.com/${escapedUsername}" target="_blank" rel="noopener noreferrer">${escapedUsername}</a>`;
             } else if (comment.author_id) {
               authorNameHTML = escapeHtml(comment.author_id.slice(0, 8) + '...');
             } else {
               authorNameHTML = 'unknown';
             }

             commentsList.innerHTML += `
               <div class="hn-comment">
                 <span class="hn-comment-author">${authorNameHTML}</span>
                 <span>(${timeAgo})</span>
                 <p>${escapeHtml(comment.content)}</p>
               </div>
             `;
           });
         }

         const commentsLink = document.querySelector(`.hn-comments-link[data-story-id="${storyId}"]`);
         if (commentsLink) {
           commentsLink.textContent = `Comments (${comments.length})`;
         }
       } catch (error) {
         commentsList.innerHTML = `<p style="font-size: 0.85rem; color: red;">Error loading comments</p>`;
       }
     }

     async function handleDeleteStory(e) {
      e.preventDefault();
      const btn = e.currentTarget || e.target;
      const storyId = btn.dataset.storyId;

      if (!currentSession) {
        alert('Please login to delete stories');
        return;
      }

      if (confirm('Are you sure you want to delete this story? All votes and comments will be removed.')) {
        try {
          // First delete all votes for this story
          const { error: votesError } = await supabase
            .from('votes')
            .delete()
            .eq('story_id', storyId);

          if (votesError) throw votesError;

          // Then delete all comments for this story
          const { error: commentsError } = await supabase
            .from('comments')
            .delete()
            .eq('story_id', storyId);

          if (commentsError) throw commentsError;

          // Finally delete the story itself
          const { error: storyError } = await supabase
            .from('stories')
            .delete()
            .eq('id', storyId)
            .eq('author_id', currentSession.user.id);

          if (storyError) throw storyError;

          // Remove story from DOM
          const storyElement = document.querySelector(`.hn-story[data-story-id="${storyId}"]`);
          if (storyElement) {
            storyElement.remove();
          }
        } catch (err) {
          alert('Failed to delete story: ' + err.message);
        }
      }
    }

    async function handlePostComment(e) {
       const btn = e.currentTarget || e.target;
       const storyId = btn.dataset.storyId;
       const commentInput = document.querySelector(`.hn-comment-input[data-story-id="${storyId}"]`);
       if (!commentInput) return;
       const content = commentInput.value.trim();
       if (!content) return alert('Comment cannot be empty!');

       try {
         if (!currentSession) {
           alert('Login to comment!');
           return;
         }

         const { error } = await supabase.from('comments').insert({
           story_id: storyId,
           content,
           author_id: currentSession.user.id
         });
         if (error) throw error;

         commentInput.value = '';
         loadComments(storyId);
       } catch (error) {
         alert('Post comment failed: ' + error.message);
       }
     }

     async function postStory() {
       const title = titleInput?.value?.trim();
       const url = urlInput?.value?.trim();
       if (!title || !url) return alert('Title and URL are required!');
      try {
        const parsed = new URL(url);
        if (!['http:', 'https:'].includes(parsed.protocol)) {
          return alert('URL must use http:// or https://');
        }
      } catch (e) {
        return alert('Invalid URL format. Please use http:// or https://');
      }

       try {
         if (!currentSession) {
           alert('Login to post!');
           return;
         }

         const { error } = await supabase.from('stories').insert({
           title,
           url,
           author_id: currentSession.user.id
           // Points are now calculated from votes, no need to initialize
         });
         if (error) throw error;

         titleInput.value = '';
         urlInput.value = '';

         // Collapse the form after posting
         if (postForm) {
           postForm.style.display = 'none';
           postForm.classList.add('hn-hide');
         }
         if (postToggle) {
           postToggle.textContent = '+ Post';
         }

         await refreshStories();
       } catch (error) {
         alert('Post story failed: ' + error.message);
       }
     }

     // Search and Sort Functions
     function performSearch() {
       try {
         currentSearchTerm = searchInput?.value?.trim() || '';
         refreshStories();
       } catch (error) {
         console.error('performSearch error:', error);
         resetRefreshState();
       }
     }

     function clearSearch() {
       try {
         currentSearchTerm = '';
         if (searchInput) searchInput.value = '';
         refreshStories();
       } catch (error) {
         console.error('clearSearch error:', error);
         resetRefreshState();
       }
     }

     function handleSortChange() {
       currentSortBy = sortSelect?.value || 'hot';
       refreshStories();
     }

     // Event Listeners
     if (loginBtnHeader) loginBtnHeader.addEventListener('click', login);
     if (logoutBtn) logoutBtn.addEventListener('click', logout);
     if (postBtn) postBtn.addEventListener('click', postStory);
     if (postToggle) {
       postToggle.addEventListener('click', (e) => {
         e.preventDefault();
         if (postForm) {
           const isHidden = postForm.style.display === 'none';
           postForm.style.display = isHidden ? 'block' : 'none';
           postForm.classList.toggle('hn-hide', !isHidden);
           postToggle.textContent = isHidden ? '- Post' : '+ Post';
         }
       });
     }

     // Event delegation for stories container - prevents memory leaks
     if (storiesContainer) {
       storiesContainer.addEventListener('click', (e) => {
         const upvoteBtn = e.target.closest('.hn-upvote-btn');
         const commentsLink = e.target.closest('.hn-comments-link');
         const postCommentBtn = e.target.closest('.hn-post-comment-btn');
         const deleteBtn = e.target.closest('.hn-delete-btn');

         if (upvoteBtn) {
           // Create a new event object with the correct target
           const newEvent = { ...e, target: upvoteBtn, currentTarget: upvoteBtn };
           handleUpvote(newEvent);
         } else if (commentsLink) {
           const newEvent = { ...e, target: commentsLink, currentTarget: commentsLink };
           toggleComments(newEvent);
         } else if (postCommentBtn) {
           const newEvent = { ...e, target: postCommentBtn, currentTarget: postCommentBtn };
           handlePostComment(newEvent);
         } else if (deleteBtn) {
           const newEvent = { ...e, target: deleteBtn, currentTarget: deleteBtn, preventDefault: e.preventDefault.bind(e) };
           handleDeleteStory(newEvent);
         }
       });
     }

     // Search and sort event listeners
     if (searchBtn) searchBtn.addEventListener('click', performSearch);
     if (clearSearchBtn) clearSearchBtn.addEventListener('click', clearSearch);
     if (sortSelect) sortSelect.addEventListener('change', handleSortChange);
     if (searchInput) {
       searchInput.addEventListener('input', (e) => {
         clearTimeout(searchDebounceTimer);
         searchDebounceTimer = setTimeout(() => {
           performSearch();
         }, 400);
       });
       searchInput.addEventListener('keypress', (e) => {
         if (e.key === 'Enter') {
           clearTimeout(searchDebounceTimer);
           performSearch();
         }
       });
     }
   }

</script>